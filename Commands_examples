Ctrl+alt+F1-F6 (command line shells)
Ctrl+alt+F7 (GUI shell)

sudo !! (re-run previous command with 'sudo' prepended)
ctrl-w (cut word behind cursor)
ctrl-k (cut all in front of cursor)
ctrl-u (cut all behind cursor)
ctrl-y (past)
ctrl + alt + - (undo)
ctrl-x-e (continue editing your current shell line in a text editor (uses $EDITOR))
alt-.  (paste previous command's argument)
!$     (last argument in last command)
!WORD  (last command starting with WORD)
Ctrl+z (suspend and move process to background)
Ctrl+c (send a SIGINT to the current foreground process)
Ctrl+d (tells the terminal to register an EOF on standard input, shell will not expect any more commands, so it exited)
CTRL+a (move to the beginning of a command (while typing))
CTRL+e (move to the end of the command (while typing))
CTRL+r (reverse history search)
CTRL+s (forward history search)
------------------------------------------------------------------------------------
Memory modules characteristics:
sudo apt-get install i2c-tools
sudo modprobe eeprom
decode-dimms                # if error then
sudo i2cdetect -l           # look for SMBus, if not present then
sudo modprobe "i2c-i801"    # SMBus adapter name taken from lspci(PCI/SMBus)
sudo i2cdetect -l
decode-dimms
--------------------------------------------------------------------------------------
For open-source radeon and amdgpu driver:
DRI_PRIME=1 %command% (VGA switch, make program use second GPU)

GALLIUM_HUD="fps,GPU-load+cpu" (overlay with different information)
GALLIUM_HUD=help glxgears (available options list)
GALLIUM_HUD="fps,GPU-load+cpu,VRAM-usage,sensors_temp_cu-radeon-pci-0d00.temp1"

GRUB_CMDLINE_LINUX_DEFAULT="radeon.cik_support=0 amdgpu.cik_support=1 radeon.si_support=0 amdgpu.si_support=1" (experimental amdgpu support)

export MESA_GL_VERSION_OVERRIDE=3.3COMPAT (overrides env variable for compatiblity OpenGL version)
---------------------------------------------------------------------------------------
LANGUAGE=ru_RU "program" (change LANGUAGE env. variable for specific program)
LANG=ru_RU.UTF-8 "program" (change LANG env. variable for specific program)

locale-gen (generate locales for languages specified in /etc/locale.gen)
update-locale --reset LANG=en_US.UTF-8 (updete and reset locale settings)

cat /usr/share/i18n/SUPPORTED (list of all supported locales)
cat /etc/locale.gen (list for locales to generate used by "locale-gen" command)
------------------------------------------------------------------------------------------------------
touch -c -t 201212101830.55 "file" (changing file mod time)
touch -d "2017-09-16 00:00:01" "file" (changing file mod time)

cut -d ':' -f1,2 filename (cut file or program output,-d - delimiter,-f - field(s) to be displayed)

cp -v /path/{file1,file2} /where/to/copy (multiple files copy)
cp -p file1 file2 (preserving the mode, ownership and timestamp)
cp ./src/*/*.h ./aaa 2>/dev/null || : (fail resistant copy)

git ls-files | sort -r | xargs rename 's/findme(?!.*\/)\/?$/replaceme/g' '{}' (Rename lookahead workaround for recursive copy)
pax -rw -pe -s/2015/2016/ source/ target/  (utility to copy a directory tree or create or unpack an archive)

git diff -D --no-index dir1/ dir2/ (difference between two directories)
cat file.txt | tee -a log.txt | cat > /dev/null (append text to log file)

tail -n 100 -f /path/to/logfile | grep "HTTP/[1-2].[0-1]\" [5]" (show only 5xx HTTP codes)

/lib64/ld-linux-x86-64.so.2 /bin/chmod +x /bin/chmod (runing the loader directly to change permissions on /bin/chmod executable)
perl -e 'chmod 0755, "foobar.file"' (using chmod() system call with perl instead of using /bin/chmod executable)

cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 100 > /path/to/file (Create a file with 100 lines, with random values)
tr -dc 'a-zA-Z0-9' (delete all other non mentioned characters)
fold -w 32 (wrap each input line to fit in specified width)

export LD_LIBRARY_PATH="/list/of/library/paths:/another/path" ./program (colon-separated set of directories where libraries should be searched for first)

stap -e 'probe syscall.mkdir { printf("%s[%d] -> %s(%s)\n", execname(), pid(), name, argstr) }' (trace a system call)

blkid "$VOLUME_NAME" || mkfs.ext4 "$VOLUME_NAME" (basically means to proceed with formatting a volume only when blkid fails)

mkpasswd -m sha-512 (create hashed password)
openssl rand -base64 16
< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c20;echo; (random string)
< /dev/urandom tr -dc _A-Z-a-z-0-9 | head -c${1:-10};echo; (random string)

logrotate -vdf CONFIG_FILE or /etc/logrotate.d (Check what will happen when logrotate is forced)
logrotate -vf CONFIG_FILE or /etc/logrotate.d (Manually force logrotate)

su www-data -s /bin/sh (switch to worker user)
ulimit -a, ulimit -Hn, ulimit -Sn (show limits)

split -d -l 200 httpd.log log (split the file into multiple pieces, -l number of lines, prefix named 'log' and add numbers to the suffix using the option -d)

ls -l /proc/<PID>/fd/ (process opened file descriptors)
echo 3 > /proc/sys/vm/drop_caches (clear the buffer-cache)

sysbench cpu --threads=2 run (cpu perfomance benchmark)
---------------------------------------------------------------------------------------
sudo growpart /dev/sda 2 (add free space to partition in virtual machine)
sudo resize2fs /dev/sda2 (resize partition)
---------------------------------------------------------------------------------------------
mount.cifs //WindowsPC/Share /home/username/Windows-Share -o user=username (WindowsPC - computer name, user=username - Windows username)

export http_proxy=http://your.proxy.server:port/ (set proxy environment variable)
export http_proxy=http://user:password@your-proxy-ip-address:port/ (set proxy environment variable with username and password)

# check the private key and the certificate match
(openssl rsa -noout -modulus -in private.key | openssl md5 ; openssl x509 -noout -modulus -in certificate.crt | openssl md5) | uniq

------------------------------------------------------------------
postgresql:

# create psql dump from conteiner mounted to mounted kuber pod
pg_dump --host '127.0.0.1' --port 5432 --username "postgres" --no-password --file "/root/mydb.backup" "wemineos"

# create database to restore the backup.
psql -h 'localhost' -p 5432 -U postgres -c "CREATE DATABASE mydatabase"

# restore the backup.
pg_restore --host 'localhost' --port 5432 --username "postgres" --dbname "mydatabase" --no-password --clean "/home/mydb.backup"
psql -f /path/to/mydb.backup (for plain text dumps)

# simple database connection check
pg_isready -d wemineos -h <database-ip> -p 5432 -U postgres
-----------------------------------------------------------------------------------------
network:
netstat -on | grep TIME_WAIT (timers on the timewait for each socket)

ip route add 192.168.200.0/24 via 127.0.0.1 (block IPs by null-routing, won't protect against most UDP attacks, packets from the remoute do reach the system)
ip route add blackhole 192.168.0.195/32 (same as above)
ip route flush cache (flush route cache to get the new routing rules to be used)

ip addr flush dev eth0 (remove all addresses assignet to interface)

brctl addbr br0 (creating the bridge interface("bridge-utils" should be installed))
brctl addif br0 eth0 eth1 (add the interfaces that are going to be bridged, br0 will lead to the existing network)
ip link set dev <bridge name> up (bring up the bridge interface)

dhclient -v -r eth0 (releases the current dhcp lease)
dhclient -v eth0 (request new IP address using dhcp)

wget -O myFile.txt domain.com/file.txt (save linked content under a desired name)
wget -r -np -R "index.html*" http://example.com/configs/.vim/ (-np/--no-parent - download only needed folder, -r/--recursive, -R/--reject)
for i in {1..3}; do wget -rnp -c -N [url]&; done; (king of multithread wget, not very pretty)

curl -Iv https://www.site.com/ or 'ip address:port' (transfer data from or to a server to test connectivity)
curl -x http://user:password@proxyhost:port site_to_connect.com (use proxy)
curl -L -o filename.tar.gz http://filename-4.0.1.tar.gz (download file with curl, -L follow the redirects)
-----------------------------------------------------------------------------------------
zip:
zip -r archivename.zip /path/to/folder/ (create archive)
# to add new files to an existing archive or update the files in an archive, use the same name for the archive file when running the zip command
zip myfilename.zip -r /home/wikileaks -e ( -e encrypt archive)
zip zipfilename -d [name of file in archive] (delete files from a zipped archive)
unzip -l test.zip (show zip archive content)
unzip test.zip (decompress archive)
unzip < file.gz > file ()
gzip -dc < file.gz > /somewhere/file (decompress a .gz file to specific directory)

tar:
tar -zcvf archive.tar.gz path/to/folder (create archive + compress(z - gzip, c - create archive, v - verbose, f - give specific name))
tar -zxvf archive.tar.gz (decompress archive(x - extract))
tar -C /myfolder -zxvf archive.tar.gz (extract to another directory)
tar tvf archive.tar (view an existing tar archive)
tar xf archive.tgz filename (extract specific file)

Gzip:
gzip file (create .gz archive)
gzip -d file.gz (decompress .gz archive)
gunzip file.gz (decompress .gz archive)
gunzip -k file.gz (decompress .gz archive. -k - Keep(don't delete) input files during compression or decompression)
-------------------------------------------------------------------------------------
usermod:
usermod -a -G groupname username (add a user in a new group, -a - append)
usermod -G GROUP1[,GROUP2,...[,GROUPN]]] username (define the groups for specific user)
usermod -L 'user' (block user from login)
------------------------------------------------------------------------------------------
xinput:
xinput --list (list input devises)
xinput --list-props 'id' (avaliable parameters for device id)
xinput --set-prop 'id' 'param' 'value' (set parameters for this dev id)
xinput --query-state 'id' (current state of different variables for this device id)

xrandr:
xrandr --output HDMI-1 --right-of eDP-1 (for double monitor setup)
--------------------------------------------------------------------------------------------------------
tee:
'command' | tee -a mylog.log (append command result output to a file and to a STDOUT(-a - append))
utility 2>&1 | tee output.log (redirect STDERR to STDOUT, both streams will be piped to the tee, data would be saved to file and reproduced in the console)
utility 2>&1 >/dev/null | more_stuff (redirect STDERR to STDOUT, will detach error messages from STDOUT and pipped them forward)
------------------------------------------------------------------------------------------------
dd:
dd if=/dev/sda bs=1M | gzip -c -9 > sda.dd.gz (clone and compress the entire /dev/sda block device, bs=1M block size, -c --to-stdout, -9 compression ratio)
dd if=/dev/zero bs=1M of=/dev/sda (overwrite the disk with zeros)
dd if=/dev/urandom bs=1M of=/dev/sda (fill the disk with random data)
-------------------------------------------------------------------------

iotop -o -b -d 5 (list of processes that read/wrote to disk)
----------------------------------------------------------------------------------------------------------------
ps:
ps -aux (all running processes, BSD-style)
ps -axjf (a and x for all processes, j for jobs format and f for ASCII art tree)
ps -efH (current running processes in a tree structure, -H for process hierarchy)
ps -ely (all running processes)
ps -aux | grep -F Z/R/S/D/T (find process by status: Z zombie, R running, S sleeping,D uninterruptible sleep/blocked state, T stopped, I idle)
ps -ef | grep -E "PID1|PID2|PID3" | grep -v grep (search multiple process PIDs)
ps -eo ppid,pid,user,stat,pcpu,comm,wchan:32 (list of processes, '-' is when the process is running or the name of kernel function in which process is sleeping)
-----------------------------------------------------------
kill:
kill -15 `lsof -t -u USER` (terminate all the processes of a specific user)
kill -s SIGCHLD [parent's pid] (ask the parent to kill its zombie child)
------------------------------------------------------------------------------------------
pacmd list-sources | grep -e 'index:' -e device.string -e 'name:' (List available input sources)
pacmd list-sinks | grep -e 'name:' -e 'index:' (list available output sinks)
pacmd list-cards (information about your sound card)
pacmd list-modules
----------------------------------------------------------------------------------
mount:
mount /dev/device /mountpoint (mount device)
mount -vf /dev/device /mountpoint (- v - verbose, -f - fake, causes  everything  to  be  done  except  for  the  actual  system call)
mount -o discard,defaults,noatime "$VOLUME_NAME" "$DATA_DIR" (-o - options)
# defaults - use the default mount options, noatime - do not update inode access times, 
# discard - discard function issues frequent commands to let the block device reclaim space freed by the filesystem.
mount -o remount,rw / (remount root partition as writable)
mount -o bind /some/where /else/where (bind mount, mounting one path into another path)
mount --bind olddir newdir (same sf above)
mount --rbind /some/where /else/where (bind mount with replicate mount points underneath)
mount -o remount,ro,bind /else/where (remount bind mount as read-only)
mount -t tmpfs tmpfs /mnt -o size=64M (mount a temporary ram partition, -t - filesystem type, -o - mount options)
---------------------------------------------------------------------------------------------
bind mount:
# /etc/fstab (for persistent bind mounts)
/some/where               /else/where              none    bind    0 0
/some/where               /readonly/       view    none    bind,ro

Using bindfs to remap user IDs:
mkdir -p /root/private/alice_disk /media/alice_disk
chmod 700 /root/private
mount /dev/sdb1 /root/private/alice_disk
bindfs --map=1000/1001:1001/1000:@1000/1001:@1001/1000 /root/private/alice_disk /media/alice_disk

mount another user's folder and files as my own ,transformations of ownership and permissions:
bindfs -u cqqrstoo ~bob/stuff ~cqqrstoo/bobs-stuff
# In /etc/fstab, that would translate to:
bindfs#/home/bob/stuff /home/cqqrstoo/bobs-stuff fuse force-user=cqqrstoo 0 0
-------------------------------------------------------------------------------
apt:
apt-get install pkg_name=version (install package of specific version, mainly for package downgrade)
apt search   (search for packages)
apt show 'package' (package info)
apt-cache policy (list of repositories in use)
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys "key" (add missing ubuntu GPG key)
apt build-dep <package> (install/remove packages in an attempt to satisfy the build dependencies)
apt changelog "package" (show changelog for specified package)
apt-mark hold package_name (exclude or hold specific package from an update)
apt-mark unhold package_name (undo package hold)
aptitude install pkg_name=version (install package of specific version, mainly for package downgrade)
aptitude why packegename (Why it is installed)
aptitude search '~i~Dpackegename' (What depends on this package)
ppa-purge ppa:user/ppa-name  (automatically downgrade the software to its original version)
apt-get install -f (remove not properly installed pakages)
apt list --installed (show installed packages)

apt install --install-recommends "package" (install recommended packages additionally to one in question)
apt-get install --reinstall -o Dpkg::Options::="--force-confmiss" <package> (reinstall package with its conffiles)
apt install --reinstall -o Dpkg::Options::="--force-confask,confnew,confmiss" <package-name> (reinstall package with its conffiles)
apt install --reinstall -o Dpkg::Options::="--force-confask,confnew,confmiss" $(dpkg -S /etc/some/directory | sed 's/,//g; s/:.*//') (restore a directory to its default)

#Every time that dpkg must install a new conffile that you have modified it will stop the upgrade and wait your answer.
apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" dist-upgrade 	# or
apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" install mypackage1 mypackage2
#you can give predefined answers to dpkg with the help of multiple --force-conf* options:
#--force-confold - do not modify the current configuration file, you need to combine it with
#--force-confdef to let dpkg overwrite configuration files that you have not modified.
#--force-confnew - always install the new version of the configuration file, the current version is kept in a file with the .dpkg-old suffix.
#--force-confmiss - ask dpkg to install the configuration file if it’s currently missing

apt purge linux-headers-xx linux-headers-xx-generic linux-image-xx-generic linux-modules-xx-generic linux-modules-extra-xxx-generic (remove kernel)
apt install linux-headers-xx linux-headers-xx-generic linux-image-xxx-generic linux-modules-xxx-generic linux-modules-extra-xxx-generic (install kernel)
-------------------------------------------------------------------------------------------
dpkg:
dpkg -i packagename (install package)
dpkg -r packagename (remove package)
dpkg --status <package> (detailed package info, includes created conffiles)
dpkg -l (list all packages)
dpkg --get-selections | grep "hold" (packages on hold)
dpkg-reconfigure (reconfigure  a  package  which   has   already   been   configured)
dpkg -i --force-confmiss <package_deb>.deb (reinstall conffiles for a .deb)
dpkg -S /path/to/file (name of the package that creates this file, what package creates thise file)
dpkg -S /path/to/dir/ (list every package that added to this dir)
dpkg --add-architecture i386 (add an extra architecture)
dpkg --remove-architecture <arch> (remove architecture)
dpkg-query -L <package> (list the contents of installed package)
dpkg --contents filename.deb (list the contents of specific .deb package)

dpkg-query -W -f='${Conffiles}\n' '*' | awk 'OFS="  "{print $2,$1}' | LANG=C md5sum -c 2>/dev/null | awk -F': ' '$2 !~ /OK$/{print $1}' | sort | less (show managed configuration files which have been changed from the default)
debsums -ce (show managed configuration files which have been changed from the default)
<packeges>=`sudo dpkg --get-selections | grep <name> | cut -f 1` (restore packages and files these packages created to its defaults)

grep -l /etc/ssh/sshd_config /var/lib/dpkg/info/*.postinst(or preinst) (search through the maintainer scripts to see what creates file)
dpkg-deb --fsys-tarfile openssh-client_*.deb | sudo tar x ./etc/ssh/ssh_config (extract file from .deb package)

dpkg --list | grep -E 'linux-image|linux-headers|linux-modules' (all installed kernel packages)
------------------------------------------------------------------------------------------
yum:
yum check-update (check for updates)
yum update package-name (update specific package)
yum install package-name (install specific package)
yum update --exclude=PACKAGENAME (skip installing or updating package)
yum --showduplicates list package-name (show available versions of specific package)
yum update-to package-version (update or install package to specific version)
yum list installed (list all installed packages)
yum list installed package-name (show if package installed and it's version)
yum list package-name (search for package)
yum search package-name (search for package)
yum info package-name (show detailed info about package)
yum deplis package-name (show dependencies for package)
yum localinstall foo.rpm (install package from local file)
yum https://server1.cyberciti.biz/foo.rpm (install package using web address)
yum downgrade package-name (downgrade a package)
yum whatprovides /etc/file (what package provide a file)

rpm -ql <package> (list the contents of installed package)
rpm -qlp filename.rpm (list the contents of specific .rpm package)
repoquery -l filename.rpm (list the contents of specific .rpm package)
--------------------------------------------------------------------------------------------------------------------
find . -type f ! -name "avoid_this_directory_please" (find with avoid command)
find . -printf "%M\t%u\t%g\t%p\n" (list of files, as ls command)
find -name "*.txt" -not -path "*/folder1/*" -not -path "*/folder2/*" (exclude folders from search)
find . -maxdepth 1 -type f -delete (maxdepth - depth of search, delete - delete found files)
find . -type d -name "name" -exec rm -rv {} + (delete folders recursively)
find . -type f -name "name" -exec rm -r --interactive=never {} + (never be interactive, never prompt)
find . -type f -not -name 'smart' -delete (-not - exclude)
find / -inum 517333 (retrieve all filenames which point to an inode number)
find / -type f -size +20M ( find all files larger than 20M)
find / -user <username> (find all file belongs to a specific user)
find / -group <groupname> (find all file belongs to a specific group)

find . -type f -name "*.txt" -exec sed -i'' -e 's/old/new/g' {} + (replace every occurrence of 'old' with 'new' recursively)
find . -type f -name "*.txt" -print0 | xargs -0 sed -i '' -e 's/old/new/g' (same but different method)

find . -type f -printf '%s %p\n'| sort -nr (List of files sorted by size)(| head -10 - can be added optionally to cut output)
find \( ! -uid `id -u` \) -o \( ! -gid `id -g` \) (find folders and files you don't own)

find . -iname "*_b.wav" -exec rename 's/_b.wav/.wav/' '{}' \; (rename files recursively, -iname - case in-sensitive)

find . -type f -print0 | tr -d -c '\0' | wc -c (number of files, recursively)
find . -type d -print0 | while read -d '' -r dir; do files=("$dir"/*); printf "%5d files in directory %s\n" "${#files[@]}" "$dir"; done  (number of files, recursively)

find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" " (last modified files)
find /etc/ -type f -mmin -$((60*24)) -exec ls -halt {} +  (list modified files in specified period of time)
find . -type f \( -iname "*.sh" -or -iname "*.jar" \) (find all .sh and .jar files)
-----------------------------------------------------------------------------------------------------------
sed:
sed -e 'command1' -e 'command2' ... -e 'commandN' files (multiple sed commands)
sed -i '10s/sh/quiet/g' (substitute the string sh with the string quiet only on line 10)
sed -i 's/# */# /g' file (add space after a specified character in a string, * - matches zero or more occurrences of the previous character)
sed -i 's/./& /15' file (add space at specified point in a string, . - matches any single character)
sed -i '2 s/Python/perl/g' python.txt (apply only to specific line(2))
sed '/^daemon/d' (deletes lines starting with daemon, ^ - matches the beginning of lines)
sed '/sh$/d' (deletes all the lines ending with sh −, $ - matches the end of lines)
/^$/    (Matches blank lines)
/^.*$/  (Matches an entire line whatever it is)
/ */    (Matches one or more spaces)

sed -e "$(sed 's:.*:s/&//ig:' wordfile)" textfile ('wordfile'is a file containing words to remove and 'textfile' containing your text)

sed -r ':a; s/\b([[:alnum:]]+)\b(.*)\b\1\b/\1\2/g; ta; s/(, )+/, /g; s/, *$//' file
# ':a' - defines a label a
# 's/\b([[:alnum:]]+)\b(.*)\b\1\b/\1\2/g' - looks for a duplicated word consisting of alphanumeric characters and removes the second occurrence
# 'ta' If the last substitution command resulted in a change, jumps back to label 'a' to try again, the code keeps looking for duplicates until none remain
# 's/(, )+/, /g; s/, *$//' These two substitution commands clean up any left over comma-space combinations

sed -n -e '10,100p' input.txt > output.txt (-n don't print each line, -e execute as a sed script, starting on line 10, until line 100 (inclusive), print (p) that line)

#<fig><image href="NEW_VALUE" align="left" placement="break"
sed 's/\(.*image href=\)[^ ]*\( .*\)/\1"NEW_VALUE"\2/' (replace the value in the first set of quotes, keeping the remainder of the line the same)
-------------------------------------------------------------------------------------------------------------------
awk:
awk 'condition { action }' filename
awk 'pattern { action }' filename
awk -F: '{print $1; print $3}' filename (print the first and third field(-F - field-separator where ":" - delimiter))
awk '{ $1=""; $2=""; print}' filename (skip first two fields and print the rest)
awk '/AAA|BBB|CCC/' filename (lines that match any of "AAA" or "BBB", or "CCC")
awk -F":" '{if ($2)print $2}' filename (print only output if the second field exists and is not empty)
awk '$1 == "word" {print $0}' filename (If field match then print the entire line)
awk '$1 != "word" {print}' filename (Print lines where field is NOT equal to "word")
awk '$1 ~ /regex/ {print}' filename (Print line if field matches regex in file)
awk '$1 !~ /regex/ {print}' filename (Print line if field does NOT match regex in file)
awk '$1 ~ /^hello$/{ print $3; }' filename (^ means $1 start, and $ is $1 end)
awk 'NR==52 { print; exit }' filename (print line number 52 and exit)
awk 'NR==8,NR==12' filename (Print lines 8 to 12 (inclusive))
awk 'NR!=1{print $1}' filename (Print first field for each record in file excluding the first record)
awk '/foo/{n++}; END {print n+0}' filename (Print total number of lines that contain foo)
awk 'length > 32' filename (Print lines with more than 32 characters in file)
awk '$1 > 200' filename (print lines with value greater than 200 in first fild)
awk '/regex/,0' filename (section of file from regular expression to end of file)
awk '/start/,/stop/' filename (Print section of a file between two regular expressions (inclusive))
awk '/regexp a/{print};/regexp b/{printf $0}' filename (lines matching "regexp a" and lines matching "regexp b" but the later ones are printed without newline)
awk -F":" '/regexp/{print $2;next}{print $3}' filename (Print field number two only on lines matching "regexp" otherwise print field number three)
awk '{total += $1}END{ print total}' filename (add numbers from specific field and print total)
awk '{total += $8}END{size=  total / 1024; printf "process total size %.2f MB\n", size}' (print process used memory)
awk 'BEGIN {count=0}; $4 ~ /regex/ {count++};END{print "some text =",count}' filename

#<fig><image href="NEW_VALUE" align="left" placement="break"
awk '/href/{$2="href=\"New_value\""}1' file (replace the value in the first set of quotes, keeping the remainder of the line the same)
--------------------------------------------------------------------------------------------------------------------
grep -rv "word_to_be_ignored" /where/to/search/ | grep "word_to_be_searched" (-r - recursive, -v - exclude)
grep -E "word1|word2|word3" (multiple word search)
grep -P '(?!.*unwanted_word)keyword' /path/to/file (find only sun, exclude sunrise)
grep -r --exclude="file" /where/to/search/ (exclude file)
grep -r --exclude-dir=var "pattern" /where/to/search/ (exclude dir)
grep  "word" -C 5/-A 5/-B 5 (-A number of lines to show after matching line, -B before, -C before and after)
grep -A4 -B4 'yyyy-mm-dd' /path/to/file
grep -E -v "80|443" | grep TCP (multiple word exclude and then search)

egrep "(pattern1|pattern2|...)" somefile (multiple pattern grep)
egrep --color "pattern1|pattern2|$" (colorized multiple pattern grep)

grep -a -C 200 -F 'string' /dev/sdXN > OutputFile (find deleted plain text files on a hard drive by directly searching on the block device,
unique string from the file you are trying to recover is needed, -C 200 - lines before and after each match of the string)

grep -oP '(?<=after )[^ ]*' (search and display text that start from 'after')
grep -Po '(?<=\after).+?(?=to)' (search and display text between 'after' ant 'to')
------------------------------------------------------------------------------------------------------------
systemd:
systemctl list-units (shows all loaded and active services, sockets, targets, timers, mounts and devices)
systemctl list-units --all (same as above but shows units regardless of whether they are currently active or not)
systemctl list-unit-files (show every available unit file within the systemd paths, including those that systemd has not attempted to load)
systemctl list-unit-files --type=service (list of all services)
systemctl status,stop,start,restart,reload,disable,enable "service" (managing services)
systemctl mask/unmask name.service (mark/unmark a unit as completely unstartable, automatically or manually)
systemctl mask/unmask name.target (enable/disable target)
systemctl cat servicename.service (display the unit file)
systemctl edit --full servicename.service (edit the unit file)
systemctl list-dependencies servicename.service (unit’s dependency tree)
systemctl list-dependencies --all servicename.service (recursively list all dependencies)
systemctl link /path/to/servicename.service (create symbolic link from one of the systemd services)
systemctl -r --type service --all
systemctl --failed (List failed units)
systemctl status pid (Show the cgroup slice, memory and parent for a PID)

systemctl --user (for user-space services)

systemd-analyze blame (system boot-up performance)
systemd-analyze critical-chain (system boot-up performance)

systemctl daemon-reload (reloads unit files and systemd configuration)
systemctl daemon-reexec (Reexecute the systemd manager)
---------------------------------------------------------------------------------------------------------
journalctl -p 3 (systemd journal, specified priority, 0 emerg, 1 alert , 2 crit, 3 err, 4 warning, 5 notice, 6 info, 7 debug)
journalctl --list-boots (list known boots)
journalctl -b 2 (systemd journal, boot selection, e.g. -2 shows two boots ago)
journalctl --since "2015-01-10 17:15:00" --until "2015-01-11 03:00" (show messages in requested time limits)
journalctl -u 'nginx.service' (log messages for specified service)
journalctl _PID=8088 (log entries that involve specified PID)
journalctl _UID=x/_GID=x (log entries that involve specified user/group)
journalctl /bin/bash (log entries that involve executable)

timedatectl status (current timezone status)
timedatectl set-timezone 'zone' (set timezone for systemd)
timedatectl set-time “13:50:00” (manually set time)
timedatectl set-ntp true (enable network clock synchronizetion)
-----------------------------------------------------------------------------------------
Nmap:
nmap -PO (-sP, -sn, -sL) 10.0.0.0/24 (host discovery)
nmap -vvv -sC -Pn -O(-A) hostname (-sC=load default scripts,-Pn=skip ping probe,-O(A)=operating system and services)
nmap -p port host (test port status)
nmap -f hostname (host port status)
nmap "-sn" -oX /path/to/hosts.xml --stylesheet=nmap.xls "host" (create report with results to file)
nmap --open (only report open ports)
nmap --reason (why port closed/filtered, etc...)
nmap --mtu 8/16/32/64 "host" (specify packets size)
nmap -D RND:10 "host" (use decoy source hosts for scanning, random number of decoys)
nmap -D decoy1,decoy2,decoy3 "host" (use decoy source hosts for scanning, manually specify the IP addresses of the decoys)
nmap --source-port "port" "target host" (source port number specification ,use specific port, common ports are: 20, 53 and 67)
nmap --script vulscan,vulners -sV HOST (run nmap scripts for finding vulnerabilities)
nmap --data-length 25 [target] (add additional data, send packets with different size than the default)
nmap -sA [target] (send the ACK packets rather than the SYN packets, firewalls treat ACK packet as the response of the SYN packet)
---------------------------------------------------------------------------------------
lsof:
lsof -i :'port/tcp/udp' (which process is listening on port or protocol)
lsof -i -P -n (established connections, ports in use, -n - don't resolve addresses)
lsof -p [PID] -R (opened files based on process PID, -R - show PPID)
lsof -u USER (list files opened by processes belonging to a specific user)
lsof -t filename (list IDs of processes that have opened a particular file)
lsof -D /path/to/directory (list all open files under a specific directory)
lsof /proc or /home (list open files of specific file system or mount point)
lsof /var/log | grep -i "deleted" (pid of files which were deleted but they are still exist in the system in deleted state)
lsof /dev/DEVICE (list all open files for specific device)

lsof -np PID | grep IPv4 (show process Internet connections)
-------------------------------------------------------------------------------------
NetworkManager:
nmcli dev show (current connection details)
nmcli device (list of network devices and their state)
nmcli connection show (list of connections, list of UUIDs)
nmcli device wifi list (list nearby wifi networks)
nmcli device wifi connect SSID password password (connect to a wifi network)
nmcli radio wifi off/on (turn off/on wifi)
nmcli connection up uuid UUID (reconnect an interface marked as disconnected)
nmcli device disconnect ifname eth0 (disconnect an interface)
nmcli connection edit 'Wired connection 2' (nmcli interactive editor to edit a connection)
------------------------------------------------------------------------------------
tcpdump:
tcpdump -D (real and virtual interfaces)
tcpdump -i "interface" -nnvvS (network activity monitoring(-nn - Don't resolve hostnames or port names,-S - absolute-tcp-sequence-numbers))
tcpdump -i "interface" -vvnne (-e - show any link layer information)
tcpdump -i "interface" -vvnn host IP_ADDR (capture all traffic to and from specific host)
tcpdump -i "interface" -vvnn net 10.0 (capture from a specific subnet, aka 10.0.x.x)
tcpdump -i "interface" -vvnn net 172.16.0.0/16 (same as above)
tcpdump -i "interface" -vvnn tcp port 80 (captures using the specified port)
tcpdump -i "interface" -vvnn proto \\icmp (captures using the specified protocol)
tcpdump -i "interface" -n vlan 100 (show tagged VLAN traffic)
tcpdump -i "interface" not and or (not - negating a filter match, and/or - combining filters)
tcpdump -nei "interface" -Q in/out host 192.168.252.125 and port 8080 (-Q direction, choose send/receive direction for which packets should be captured)

tcpdump -i "interface" ether proto 0x88cc -v -c 5 (possibly capture Ethernet traffic)
----------------------------------------------------------------------------------------
iptables:
-t NAT,Filter,Mangle (add rule to the specific table)
-P CHAIN action (set the chain default policy)
-A INPUT,OUTPUT (append rule to the specific chain, a chain is a group of rules)
-j ACCEPT,REJECT,DROP (tells what to do if a packet matches the constraints specified in the previous arguments)
-j MASQUERADE (replacing the sender's address by the router's address)
-p tcp,udp,icmp,all (set the protocol this rule will apply to)
-m tcp,udp,conntrack,state,limit (modules)
--dport '' --sport '' (apply only to specific source or destination port)
--dport port -s address (apply only to specific port for specific IP)
-i/-o (specify input/output interface)
-I chain [rule-number] firewall-rule (insert rule in the chain as the given rule number, default is 1)
-p ! protocol -s ! address (! - except)
-p protocol --match multiport --sports portRange1:PortRange2 (port range)
-p protocol --match multiport --sports port1,port2 (rule for multiple ports)
-j REDIRECT --to-ports 'port' (redirect)

iptables -D "rule" (delete specific rule)
iptables -F (clear all rules)
iptables -t nat -X (-X deletes all empty non-default chains in a table)
iptables -t table -F chain (clear all rules in chain)
iptables -nvL --line-numbers (show current rules)
iptables -S (show commands used to create your current rules)
iptables -L (show all current rules)
iptables -t filter/nat/mangle -L --line-numbers -n -v (show current rules from specified table)
iptables-save > file-with-iptables-rules.txt (save current rules to a file)
iptables-restore < file-with-iptables-rules.txt (load rules from a file)

iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-ports 8080 (incoming packets going to port 80 will be redirected to port 8080)
iptables -t nat -A POSTROUTING -o eth1 -j MASQUERADE (NAT, -o eth1 - output interface, connected to the internet)
iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT (forward packets from your internal network to your external network)
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT (as above, but from external to internal)
iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to 172.31.0.23:80 (make local server(172.31.0.23) to be accessible from outside)
iptables -A FORWARD -i eth0 -p tcp --dport 80 -d 172.31.0.23 -j ACCEPT (make NAT routing possible if FORWARD have the default rule to DROP)
iptables -t raw -A PREROUTING -p tcp --sport 80 -j NOTRACK (bypass connection tracking, it is a security risk to disable tracking, unless you are already behind a stateful firewall)
iptables -A OUTPUT -p tcp -m tcp --dport 443 -m state --state NEW -j ACCEPT (default output rule example)
iptables -A OUTPUT -p tcp -m multiport --dports 2240,2257,2258 -m state --state NEW -j ACCEPT (multiport rule example)
iptables -A OUTPUT -p udp -m udp --dport 67:68 -m state --state NEW -j ACCEPT (ports range example)
iptables -A INPUT -i <interface> -p tcp -m multiport --source-port 80,443 -d $IPADDR ! --syn --dport 1024:65535 -j ACCEPT (example)
iptables -t nat -A PREROUTING -p tcp -j BALANCE --to-destination <ip address>-<ip address> (BALANCE nat Table, BALANCE target uses a range of addresses)
iptables -A OUTPUT -s 10.0.0.0/24 -p tcp -j ACCEPT (accept all packets from local network)
iptables -A INPUT/OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT (allow traffic from already established connections)
iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0/24 --dport 873 -m state --state NEW -j ACCEPT (allow traffic from specific hosts on specific interface)
iptables -A INPUT -s 209.175.453.23 -p tcp --dport 22 -j DROP (drop traffic from specific IP on specific port)
iptables -A INPUT -p tcp -s ! 1.2.3.4 --dport 80 -j DROP (Block Incomming Port 80 except for IP Address 1.2.3.4)
iptables -t raw -A PREROUTING -s 1.2.3.4 -j DROP (block traffic before routing)
-----------------------------------------------------------------------------------
ssh:
ssh-copy-id username@remote-server.org (automatically copy your public key to authorized_keys of specified server)

ssh -L 1234:localhost:2812 User@remotehost (tunnel with ssh, forwards the local port 1234 to the remote port 2812. -L - local forwarding, forward all connection attempts on local port to remote port on the remote host, which can be reached from the remote host machine)
ssh -L 80:localhost:80 SUPERSERVER (connection made to the local port 80 is to be forwarded to port 80 on SUPERSERVER)

ssh -R 50505:localhost:22 User@remotehost (tunnel with ssh, forwards the remote port 50505 to the local port 22. -R - remote forwarding, forward all connection attempts to the remote port to local port on local host, which can be reached from your local machine)
ssh -R 80:localhost:80 tinyserver (connection made to the port 80 of tinyserver is to be forwarded to port 80 on your local machine)

ssh -g -L 9000:localhost:3000 user@example.com (remote forwarding followed by a local forwarding, but from the remote server. -g allows remote hosts to connect to local forwarded ports and this will make loopback port 3000 on the server accessible on all interfaces on port 9000)

ssh -N -D 8080 user@host -p 80 (tunnel with ssh, -N - don't login, -D - Dynamic port forwarding allows communication across a range of ports. This makes SSH acts as a SOCKS proxy server. A SOCKS proxy is a simple SSH tunnel in which specific applications forward their traffic through the tunnel to the remote server, then the proxy forwards the traffic out to the general internet. Has to be configured for each application separately on the client machine.

ssh -D 9000 -f -C -q -N user@host (-D create a SOCKS tunnel on the the port 9000, -C compresses, -q enables quiet mode, -f forks the process to the background)
ssh -f -T -N -L 5000:localhost:3306 user@host -p 1022 -i ~/.ssh/id_rsa (-T disable pseudo-terminal allocation, -p port, -i different private keys)

ssh user@host 'COMMAND1; COMMAND2; COMMAND3' (run multiple command on a remote host over ssh)
ssh user@host 'bash -s' < SCRIPT (Run Bash Script on Remote Server)
ssh -o StrictHostKeyChecking=no user@host -i ~/.ssh/id_rsa "command" > ./test.txt (Don't check host identity, run command on remote host and redirect its output to file on local host)
ssh -o ConnectTimeout=10 user@host (set connection timeout)

ssh-keygen -t rsa -b 4096 (create 4096-bit RSA key pair, default is 2048-bit)

ssh-add - <<< "${SSH_PRIVATE_KEY}" (add shh key from variable)
ssh-add <(echo "$PRIVATE_KEY") (add shh key from variable)
----------------------------------------------------------------------------------------------
Compiling:
./configure (execute a configuration script (checks for dependencies and compiler quirks then creates "make" files))
./configure --prefix=directory (compile the software for installation somewhere other than the default)
make -j4 (execute make to compile the source code, "-j#" - starting several compiler "jobs" simultaneously)
make clean (removes existing binaries that were from a previous build)
make install (install the binaries that the compiler created)
checkinstall (create a package from binaries to register the software with the Debian package tool)
-------------------------------------------------------------------------------------------------
Git:
git clone <url> (clone git project from web)
git clone --recurse-submodules -j8 <url> (git clone including submodules)
git clone <url> folder-name (clone to specific directory)
git init (create git database in current directory)
git status (git status for current directory)
git add hello.html (Staging the changes to file)
git add -A (stage all repository changes)
git checkout hello.html (Discarding local changes (before staging))
git reset HEAD hello.html (cancel staged changes)
git commit -m "comment" (commit staged changes)
git commit --amend -m "comment" (change the previous commit)
git revert HEAD --no-edit (create a commit that deletes the changes saved by unwanted commit)
git reset --hard <hash> (changes the branch pointer to point at any commit in the tree)
git revert HEAD~1..HEAD (Revert the branch to the previous commit)
git log --all (see git log)
git log --pretty=oneline (single line format)
git remote add <name> <url> (add remote repository to local git database)
git push -u <name> <branch_name> (push changes to new remote repository, or to new branch)
git push (push changes to remote repository)
git pudh -f (force push your current branch status, will override remote status)
git pull (pull changes from remote repository)
git branch (show current branch)
git branch -a (show all branches)
git checkout <hash> (checkout previous snapshot)
git checkout -b <branch_name> (add new branch)
git checkout <branch_name> (switch to another branch)
git checkout -- . (discard all unstaged changes)
git checkout -- path/to/file/to/revert (discard for a specific file)
git merge <branch_name> (merge current branch in to another branch)
git tag (show tags)
git tag <tag-name> (tag current commit with new tag)
git push origin <tag-name> (Push the tag to the remote origin)

git push origin :refs/tags/<tagname> (Delete the tag on any remote before you push)
git tag -fa <tagname> (Replace the tag to reference the most recent commit)


git config --global user.name <Your Name> (set up your name)
git config --global user.email <your_email@whatever.com> (set up your e-mail)
git config --global diff.tool <Program Name> (set up your diff tool(git difftool))
git config --global merge.tool <Program Name> (set up your merge tool(git mergetool))

git remote set-url origin git@github.com:username/repository.git (change git to use key authentication)
----------------------------------------------------------------------------------------
udev:
udevadm info -a -n /dev/sda (List the attributes of a device)
udevadm info -a -p /sys/class/backlight/intel_backlight (list all attributes of a specific system path)
udevadm monitor --environment --udev (monitor environment variables while unplugging your device)
udevadm test $(udevadm info -q path -n device_name) 2>&1 (testing rules before loading, it will not perform all actions in your new rules but it will however process symlink rules on existing devices)
udevadm test /sys/class/backlight/acpi_video0/ (test the udev rule for specific device/system path)
udevadm control --reload (If rules fail to reload automatically)
#/etc/udev/rules.d/30-radeon-pm.rules (persistent udev rule for GPU power management, if the rules are failing, try removing the dri/ prefix)
KERNEL=="dri/card0", SUBSYSTEM=="drm", DRIVERS=="radeon", ATTR{device/power_dpm_force_performance_level}="high"
-------------------------------------------------------------------------------------
cgroups:
cgm create <controller> <cgroup>
cgm create cpu    groupname (create a new cgroup named groupname with cpu controller)
cgm create memory groupname (create a new cgroup named groupname with memory controller)
cgm chown <controller> <cgroup> uid gid
cgm chown  memory groupname 1000 0  (change cgroup to user ID `1000` and system group root (GID 0))
chown user /sys/fs/cgroup/{memory,cpu}/groupname/* (change ownership in all cgroup subgroups)
cgm movepid <controller> <cgroup> pid
cgm movepid memory groupname $pid (move process to cgroup named groupname in controller memory)
cgm movepid cpu groupname $pid_of_bash (move bash to cgroup named groupname in controller cpu)
cgm setvalue memory groupname memory.limit_in_bytes 10000000 (limit the memory usage of all processes in this group to ~10 MB, once tasks hit this limit, they will begin to swap)
echo 100 > /sys/fs/cgroup/cpu/groupname/foo/cpu.shares (CPU priority ("shares") of this group. By default all groups have 1024 shares. A group with 100 shares will get a ~10% portion of the CPU time)
cgm setvalue freezer groupname freezer.state FROZEN (freeze cgroup named groupname)

# Attach the memory subsystem to a hierarchy and create a cgroup:
mount -t memory -o memory memory /cgroup/memory
mkdir /cgroup/memory/blue
# Set the amount of memory which tasks in the blue cgroup can use to 100 MB:
echo 104857600 > memory.limit_in_bytes

cgcreate -g cpu:/cpulimited
cgset -r cpu.shares=512 cpulimited
cgexec -g cpu:cpulimited COMMAND

namespaces:
readlink /proc/*/task/*/ns/* | sort -u (list of currently presented namespaces in the system)
unshare -u /bin/bash (create a shell in new UTS namespace)
----------------------------------------------------------------------------------------
rsync:
rsync -avh --progress /path/to/source /path/to/destination (copy file or folder)
rsync -a --delete --quiet /folder/to/backup /location/of/backup (-a - archived and syncs recursively)
rsync -a --delete local-file user@remote-host:remote-file (--delete - delete from destination if removed from source)
rsync -a --exclude=pattern_to_exclude user@remote-host:remote-file local-file
rsync -a --delete --quiet -e ssh /folder/to/backup user@host:/location/of/backup (-e ssh - use ssh)

rsync -r --progress source destination (transferring and synchronizing local files, -r -recursive)
rsync -av --progress --delete source destination (sync the contents of source to destination on the same system)
rsync -ve ssh source user@host:destination (transferring and synchronizing remote files, -u - ignore same files)
rsync --progress -avHXAe ssh user@server:/path/to/file /home/user/path/to/file (download from a server)
rsync -avHXA --progress /home/user/path/to/file -e ssh user@server:/path/to/file (upload to a server)
rsync -a --include '*/' --include '*.txt' --exclude '*' source/ target/  (Copy specific file type keeping the folder structure)

rsync -avHe -e "ssh -p 2222" user@example.com:/files/ /local/files/ (connect to server though ssh on port 2222 and sync all files from /files/ to /local/files)
rsync -e "ssh -p 12022 -o StrictHostKeyChecking=no" -avHe user@example.com:/files/ /local/files/ (same as above but with option StrictHostKeyChecking=no)
rsync -Pav -e "ssh -i $HOME/.ssh/somekey" username@hostname:/from/dir/ /to/dir/ (download from a server using ssh key)
-----------------------------------------------------------------------------------------
gdb:
gdb /path/to/file (start an app with debug)
gdb -p PID (debug already running process using its PID)
gdb attach PID -ex cont (Attach to the process and execute 'cont' to resume process execution)
gdb appname, bt full (GNU debugger)
gdb appname core, bt full (GNU debugger, get a backtrace)

gdb: call close($fileDescriptor(fd)) (close the socket opened by process)
gdb: call shutdown($fileDescriptor, 0) (simulate the socket being closed by the remote end)
gdb: cont (resume process execution)
gdb: quit (detach gdb)

gdb -p PID --batch -ex 'call close(4)' (close the socket in one go without invoking the gdb shell)
gdb -p PID --batch -ex 'call shutdown(4, 2)' (closes the connection while keeping the socket valid in one go without invoking the gdb shell)
#The close() function can be dangerous when used on multi-threaded applications. There is an easy solution for sockets: use shutdown() instead of close().
#The shutdown() function closes the connection, while keeping the socket valid. Also, it actually wakes up threads in a blocking operation in most implementations.
-----------------------------------------------------------------------------------------
strace:
strace appname (start an app with tracing system calls and signals)
strace -p PID (Attach to the process ID)

strace -e open appname (what this program tries to open)
strace -e trace=read,write -p <PID> (print all read and write system calls by the process)
strace -e trace=network -p <PID> (trace all the network related system calls)
strace -e trace=signal -p <PID> (trace all signal related system calls)
strace -e trace=ipc -p <PID> (trace all IPC related system calls)
strace -e race=desc -p <PID> (trace all file descriptor related system calls)
strace -e trace=memory -p <PID> (trace all memory mapping related system calls)
--------------------------------------------------------------------------------
LVM:
lvextend -L +500M /dev/vgroup/lvolume (extending the size of LVM partition by 500MB)
lvextend -l +100%FREE /dev/vgroup/lvolume (extending all available free space)
resize2fs /dev/vgroup/lvolume (to resize ext filesystems)
xfs_growfs mountpoint_for_/dev/vgroup/lvolume (to resize xfs filesystems)
---------------------------------------------------------------------------------------
tmux:
tmux (start tmux server)
tmux new -s session-name (create a new session)
tmux ls (list tmux sessions)
tmux attach -t session-name (attach to session)
tmux kill-session -t session-name (kill session)

ctrl+b <command> (tmux, do this command)
ctrl+b c (create a new window)
ctrl+b , (rename window)
ctrl+b p/n (change window: previous/next)
ctrl+b w (list/change windows)

ctrl+b % (Split the window vertically)
ctrl+b " (Split window horizontally)
ctrl+b q (Show pane numbers, when the numbers show up type the key to go to that pane)
ctrl+d   (close window or pane)
-----------------------------------------------------------------------------------------------
